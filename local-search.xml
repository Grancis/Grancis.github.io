<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>关于前端跨域</title>
    <link href="/2020/10/06/%E5%85%B3%E4%BA%8E%E5%89%8D%E7%AB%AF%E8%B7%A8%E5%9F%9F/"/>
    <url>/2020/10/06/%E5%85%B3%E4%BA%8E%E5%89%8D%E7%AB%AF%E8%B7%A8%E5%9F%9F/</url>
    
    <content type="html"><![CDATA[<h2 id="Cross-Origin-Resource-Sharing-CORS"><a href="#Cross-Origin-Resource-Sharing-CORS" class="headerlink" title="Cross Origin Resource Sharing (CORS)"></a>Cross Origin Resource Sharing (CORS)</h2><h3 id="什么是跨域"><a href="#什么是跨域" class="headerlink" title="什么是跨域"></a>什么是跨域</h3><p>跨域是浏览器的一种安全机制。为了确保页面从api获取的信息安全可信，浏览器要求前端的请求的api域名与站点在同一域名下。</p><p>例如，本网页挂载在 <code>www.a.com</code> 上，网页需要请求 <code>www.b.com</code> 上的<code>api</code>，这个过程就是跨域资源共享，即跨域。实际上，请求的资源与网页的ip相同而端口不同时也是跨域行为。</p><p>发生跨域事件时，默认情况下，浏览器会阻止该资源请求。在前后端分离的项目中，前端项目在本地运行，后端api在云服务器上，调用后端api时便会发生跨域问题。可以分别从前端和后端两个方面解决这个问题。</p><h3 id="前端解决跨域问题"><a href="#前端解决跨域问题" class="headerlink" title="前端解决跨域问题"></a>前端解决跨域问题</h3><p>在<code>node.js</code>生态中进行前端开发时，框架往往会提供一个开发环境用于实时调试。这个开发环境实际上就是一个http服务器，它的功能功能就是对用户的代码进行热更新，实时打包后部署在本地的某个端口上，用户在浏览器中访问 <code>http://localhost:8080</code> 这样的地址就能实时预览到开发的页面效果。</p><p>于是，要在前端解决跨域问题便可以从框架为我们提供的http服务器入口，只需要在框架中配置对后端<code>api</code>的代理访问，就可以保证前端页面和<code>api</code>处于同一源，即框架提供的http服务器。</p><p><img src="/img/post/%E8%B7%A8%E5%9F%9F%E4%BB%A3%E7%90%86%E8%AF%B4%E6%98%8E-1.png"></p><p>使用 <code>vue-cli 2.x</code> 时，需要在 <code>/config/index.js/</code> 中增加<code>proxyTable</code>配置</p><pre><code class="hljs JavaScript"><span class="hljs-built_in">module</span>.exports = &#123;  <span class="hljs-comment">//...</span>  dev: &#123;    <span class="hljs-comment">//....</span>    proxyTable: &#123;      <span class="hljs-string">&#x27;/api&#x27;</span>: &#123;        target:<span class="hljs-string">&#x27;http://www.example.com&#x27;</span>, <span class="hljs-comment">//这里就是后端api的url地址</span>        changeOrigin: <span class="hljs-literal">true</span>,        withCredentials:<span class="hljs-literal">true</span>,        pathRewrite: &#123;          <span class="hljs-string">&#x27;^/api&#x27;</span>: <span class="hljs-string">&#x27;&#x27;</span>        &#125;      &#125;,    &#125;,    <span class="hljs-comment">//....</span>  &#125;&#125;</code></pre><p>使用 <code>vue-cli 3.x</code> 时, 对应的配置在根目录的 <code>vue.config.js</code> 中(没有此文件新建一个)：</p><pre><code class="hljs JavaScript"><span class="hljs-built_in">module</span>.exports = &#123;  <span class="hljs-comment">//...</span>  devServer: &#123;    <span class="hljs-comment">//....</span>    proxy: &#123;      <span class="hljs-string">&#x27;/api&#x27;</span>: &#123;        target:<span class="hljs-string">&#x27;http://www.example.com&#x27;</span>, <span class="hljs-comment">//这里就是后端api的url地址</span>        changeOrigin: <span class="hljs-literal">true</span>,        withCredentials:<span class="hljs-literal">true</span>,        pathRewrite: &#123;          <span class="hljs-string">&#x27;^/api&#x27;</span>: <span class="hljs-string">&#x27;&#x27;</span>        &#125;      &#125;,    &#125;,    <span class="hljs-comment">//....</span>  &#125;&#125;</code></pre><p>实际上<code>vue-cli 2.x</code>使用的是<code>webpack</code>通用的配置方式，<code>vue-cli 3.x</code>是对webpack的再封装，以<code>vue-cli</code>自己的方式进行配置，大同小异。</p><p>配置完成后需要重启调试服务器。</p><pre><code class="hljs bash"><span class="hljs-comment"># vue-cli 2.x</span>npm run dev</code></pre><p>增加此配置后，原来访问的<code>api</code>地址则从 <code>http://www.example.com/api</code> 变更为 <code>/api</code>。 框架会匹配<code>/api</code>并代替浏览器完成资源请求，再将结果通过 <code>/api</code>的请求（浏览器发起的请求）返回到页面。这个过程就是代理。更多的路径匹配方式可以查询webpack的文档。<code>pathRewrite</code>可以对路径进行个性化重写，留空表示不重写。</p><p>通过代理的方式让原本处于不同源的资源能够在站点所在源下访问到，从而解决的跨域请求的问题。</p><h3 id="nginx反向代理解决跨域"><a href="#nginx反向代理解决跨域" class="headerlink" title="nginx反向代理解决跨域"></a>nginx反向代理解决跨域</h3><p>上述方法只能在开发环境下解决跨域问题。当开发的网页中需要用到第三方不允许跨域的<code>api</code>时，在生产环境中也会面临跨域问题。此时可以利用nginx的反向代理解决，其原理与在前端调试服务器中配置请求代理一致。</p><p>后端http服务器框架都可以配置静态资源，从而使得前端开发的页面和后端开发<code>api</code>处于同一个源。而第三方的<code>api</code>无法让其处于同一个源，所以必须使用代理。可以后端的http服务器中编写代理功能，也可以使用<code>nginx</code>这样的工具来完成这一功能。</p><p><code>nginx</code>是很常用的http服务器架设工具，易于配置、功能强大。对需要代理的请求路径进行匹配即可完成代理。</p><pre><code class="hljs bash">location ^~/api/ &#123;proxy_pass http://www.example.com;            proxy_set_header X-Real-IP <span class="hljs-variable">$remote_addr</span>;            proxy_set_header Host <span class="hljs-variable">$host</span>;proxy_set_header X-Forwarded-For <span class="hljs-variable">$proxy_add_x_forwarded_for</span>;        &#125;</code></pre><p><code>^~/api/</code>是指匹配以<code>/api/</code>开头的请求路径，更多的匹配规则自行百度。</p><p><code>proxy_pass</code> 是设置目标地址。</p><p><code>proxy_set_header</code> 的设置是对http请求的header内容进行copy。</p><blockquote><p>注意：使用nginx进行反向代理时以为着前端静态资源是用nginx挂载的，与自己写的后端<code>api</code>不是在同一端口上，所以自己写<code>api</code>接口也需要配置反向代理</p></blockquote><h3 id="后端与跨域"><a href="#后端与跨域" class="headerlink" title="后端与跨域"></a>后端与跨域</h3><p>对于自己编写的<code>api</code>，如果不希望前端在使用的时候出现跨域问题可以在http服务器框架中配置关闭这一限制。不同的框架，如<code>python</code>的<code>flask</code>、<code>Java</code>的<code>spring-boot</code>都可以轻松配置，不一一赘述。</p>]]></content>
    
    
    
    <tags>
      
      <tag>前端</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
