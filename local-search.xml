<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>读《月亮与六便士》</title>
    <link href="/posts/post_read_ylylbs/"/>
    <url>/posts/post_read_ylylbs/</url>
    
    <content type="html"><![CDATA[<h3 id="故事概述"><a href="#故事概述" class="headerlink" title="故事概述"></a>故事概述</h3><p>故事的主人公叫斯特里·克兰德，他原本是一位家庭美满、事业有成的证券经纪人。按照常人的思维，他已经处于人生巅峰，只需要平平稳稳的经营好现有的生活就是完美的一生了。然而他抛弃了世人都认可的、令人羡慕的生活，他独自一人、远走他乡从伦敦去到巴黎画画。</p><p>主人公去到巴黎的他没有再找一份自己擅长的证券相关的工作，而是以画画谋生。不出所料，他变得穷困潦倒，在巴黎吃尽了苦头。但所谓的“吃尽苦头”都是他人的看法，他在巴黎的朋友看到他穷困的样子接济了他，然而他却没有对朋友表现出一丁点感激之情，反而是冷眼相待。主人公变成了一个残忍冷酷的人，对世俗的一切表现得冷嘲热讽、傲慢不屑，唯独对艺术表现出一种本能的热情和无法抗拒的追求。</p><p>最终，主人公身边的人厌倦了他这个疯子，他更是厌倦了世俗社会，一个人去到南太平洋的一个岛屿上，与当地的土著结婚生子，过着与当代人类文明隔绝的生活。主人公最后在家里的四面墙壁上创作出了不朽之作，但却在得知自己身患绝症之后，叮嘱土著妻子一把火将壁画烧去，就这样一件杰作化为乌有。</p><h3 id="月亮与六便士"><a href="#月亮与六便士" class="headerlink" title="月亮与六便士"></a>月亮与六便士</h3><p>整本书并没有提到月亮与六便士，而是用主人公的经历诠释了这两件物品。皎洁的月亮高高在上，对主人公来说是他执着追求的艺术创作；而世人所奉承的功名、利益、钱财对于主人公来说只是地上的六便士，不值一提。理想在天上，遥不可及；世俗的利益在地上，触手可及，而主人公却毅然决定的选择追求天上的理想。</p><p>故事给我们描述了一个几乎极端的人物形象，为了追求自己的理想，不但抛弃功名利益还断绝了与世界的联系。这样一个极端的人在世俗社会看来是个疯子，但这是个为理想疯狂的疯子，他告诉我们如何对待追求自己的理想。</p><p>当我们尝试追求一个遥远的目标，眼前总是会有更简单易得的利益，放弃既得利益走向远方需要勇气，也必须有这样的勇气才有可能成就更大的梦想，因为这是追寻梦想的开始，就像主人公离开伦敦去到巴黎一样。</p><p>放弃利益去追求一个遥远的目标，在大多数旁人看来是愚蠢的。因此在追寻梦想的路上少不了人们的嘲笑。主人公的身边的人嘲讽他，他不但不在乎更是有一种世人愚昧的傲慢，最终选择与世隔绝。生活在现代的我们不该与世隔绝，但主人公那种无视他们嘲笑，以自己的梦想的态度是我们在实现理想的路上必不可少的。说到底，就是对目标的执着，有一份像主人公对艺术一样的执着，就能够坚持走下去，就能够不受他人影响地走下去。</p>]]></content>
    
    
    
    <tags>
      
      <tag>读书</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于前端跨域</title>
    <link href="/posts/post_cors_solving/"/>
    <url>/posts/post_cors_solving/</url>
    
    <content type="html"><![CDATA[<h2 id="Cross-Origin-Resource-Sharing-CORS"><a href="#Cross-Origin-Resource-Sharing-CORS" class="headerlink" title="Cross Origin Resource Sharing (CORS)"></a>Cross Origin Resource Sharing (CORS)</h2><h3 id="什么是跨域"><a href="#什么是跨域" class="headerlink" title="什么是跨域"></a>什么是跨域</h3><p>跨域是浏览器的一种安全机制。为了确保页面从api获取的信息安全可信，浏览器要求前端的请求的api域名与站点在同一域名下。</p><p>例如，本网页挂载在 <code>www.a.com</code> 上，网页需要请求 <code>www.b.com</code> 上的<code>api</code>，这个过程就是跨域资源共享，即跨域。实际上，请求的资源与网页的ip相同而端口不同时也是跨域行为。</p><p>发生跨域事件时，默认情况下，浏览器会阻止该资源请求。在前后端分离的项目中，前端项目在本地运行，后端api在云服务器上，调用后端api时便会发生跨域问题。可以分别从前端和后端两个方面解决这个问题。</p><h3 id="前端解决跨域问题"><a href="#前端解决跨域问题" class="headerlink" title="前端解决跨域问题"></a>前端解决跨域问题</h3><p>在<code>node.js</code>生态中进行前端开发时，框架往往会提供一个开发环境用于实时调试。这个开发环境实际上就是一个http服务器，它的功能功能就是对用户的代码进行热更新，实时打包后部署在本地的某个端口上，用户在浏览器中访问 <code>http://localhost:8080</code> 这样的地址就能实时预览到开发的页面效果。</p><p>于是，要在前端解决跨域问题便可以从框架为我们提供的http服务器入口，只需要在框架中配置对后端<code>api</code>的代理访问，就可以保证前端页面和<code>api</code>处于同一源，即框架提供的http服务器。</p><p><img src="/img/post/%E8%B7%A8%E5%9F%9F%E4%BB%A3%E7%90%86%E8%AF%B4%E6%98%8E-1.png"></p><p>使用 <code>vue-cli 2.x</code> 时，需要在 <code>/config/index.js/</code> 中增加<code>proxyTable</code>配置</p><pre><code class="hljs JavaScript"><span class="hljs-built_in">module</span>.exports = &#123;  <span class="hljs-comment">//...</span>  dev: &#123;    <span class="hljs-comment">//....</span>    proxyTable: &#123;      <span class="hljs-string">&#x27;/api&#x27;</span>: &#123;        target:<span class="hljs-string">&#x27;http://www.example.com&#x27;</span>, <span class="hljs-comment">//这里就是后端api的url地址</span>        changeOrigin: <span class="hljs-literal">true</span>,        withCredentials:<span class="hljs-literal">true</span>,        pathRewrite: &#123;          <span class="hljs-string">&#x27;^/api&#x27;</span>: <span class="hljs-string">&#x27;&#x27;</span>        &#125;      &#125;,    &#125;,    <span class="hljs-comment">//....</span>  &#125;&#125;</code></pre><p>使用 <code>vue-cli 3.x</code> 时, 对应的配置在根目录的 <code>vue.config.js</code> 中(没有此文件新建一个)：</p><pre><code class="hljs JavaScript"><span class="hljs-built_in">module</span>.exports = &#123;  <span class="hljs-comment">//...</span>  devServer: &#123;    <span class="hljs-comment">//....</span>    proxy: &#123;      <span class="hljs-string">&#x27;/api&#x27;</span>: &#123;        target:<span class="hljs-string">&#x27;http://www.example.com&#x27;</span>, <span class="hljs-comment">//这里就是后端api的url地址</span>        changeOrigin: <span class="hljs-literal">true</span>,        withCredentials:<span class="hljs-literal">true</span>,        pathRewrite: &#123;          <span class="hljs-string">&#x27;^/api&#x27;</span>: <span class="hljs-string">&#x27;&#x27;</span>        &#125;      &#125;,    &#125;,    <span class="hljs-comment">//....</span>  &#125;&#125;</code></pre><p>实际上<code>vue-cli 2.x</code>使用的是<code>webpack</code>通用的配置方式，<code>vue-cli 3.x</code>是对webpack的再封装，以<code>vue-cli</code>自己的方式进行配置，大同小异。</p><p>配置完成后需要重启调试服务器。</p><pre><code class="hljs bash"><span class="hljs-comment"># vue-cli 2.x</span>npm run dev</code></pre><p>增加此配置后，原来访问的<code>api</code>地址则从 <code>http://www.example.com/api</code> 变更为 <code>/api</code>。 框架会匹配<code>/api</code>并代替浏览器完成资源请求，再将结果通过 <code>/api</code>的请求（浏览器发起的请求）返回到页面。这个过程就是代理。更多的路径匹配方式可以查询webpack的文档。<code>pathRewrite</code>可以对路径进行个性化重写，留空表示不重写。</p><p>通过代理的方式让原本处于不同源的资源能够在站点所在源下访问到，从而解决的跨域请求的问题。</p><h3 id="nginx反向代理解决跨域"><a href="#nginx反向代理解决跨域" class="headerlink" title="nginx反向代理解决跨域"></a>nginx反向代理解决跨域</h3><p>上述方法只能在开发环境下解决跨域问题。当开发的网页中需要用到第三方不允许跨域的<code>api</code>时，在生产环境中也会面临跨域问题。此时可以利用nginx的反向代理解决，其原理与在前端调试服务器中配置请求代理一致。</p><p>后端http服务器框架都可以配置静态资源，从而使得前端开发的页面和后端开发<code>api</code>处于同一个源。而第三方的<code>api</code>无法让其处于同一个源，所以必须使用代理。可以后端的http服务器中编写代理功能，也可以使用<code>nginx</code>这样的工具来完成这一功能。</p><p><code>nginx</code>是很常用的http服务器架设工具，易于配置、功能强大。对需要代理的请求路径进行匹配即可完成代理。</p><pre><code class="hljs bash">location ^~/api/ &#123;proxy_pass http://www.example.com;            proxy_set_header X-Real-IP <span class="hljs-variable">$remote_addr</span>;            proxy_set_header Host <span class="hljs-variable">$host</span>;proxy_set_header X-Forwarded-For <span class="hljs-variable">$proxy_add_x_forwarded_for</span>;        &#125;</code></pre><p><code>^~/api/</code>是指匹配以<code>/api/</code>开头的请求路径，更多的匹配规则自行百度。</p><p><code>proxy_pass</code> 是设置目标地址。</p><p><code>proxy_set_header</code> 的设置是对http请求的header内容进行copy。</p><blockquote><p>注意：使用nginx进行反向代理时以为着前端静态资源是用nginx挂载的，与自己写的后端<code>api</code>不是在同一端口上，所以自己写<code>api</code>接口也需要配置反向代理</p></blockquote><h3 id="后端与跨域"><a href="#后端与跨域" class="headerlink" title="后端与跨域"></a>后端与跨域</h3><p>对于自己编写的<code>api</code>，如果不希望前端在使用的时候出现跨域问题可以在http服务器框架中配置关闭这一限制。不同的框架，如<code>python</code>的<code>flask</code>、<code>Java</code>的<code>spring-boot</code>都可以轻松配置，不一一赘述。</p>]]></content>
    
    
    
    <tags>
      
      <tag>前端</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
